// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY ValueVariant.Generator. DO NOT CHANGE IT.
// </auto-generated>

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

using MessagePack;
using MessagePack.Formatters;

#if NETCOREAPP2_1_OR_GREATER
using System.Diagnostics.CodeAnalysis;

#nullable enable
#endif

namespace Sample
{
    using V2 = global::System.ValueVariant;

    using T = global::Sample.CharacterId;

    using T1 = global::Sample.PlayerId;
    using T2 = global::Sample.NpcId;

    [MessagePackFormatter(typeof(CharacterId.MessagePackFormatter))]
    readonly partial struct CharacterId : IEquatable<T>,
        V2.Details.IValueVariantElement<T1>, V2.Details.IValueVariantElement<T2>
    {
        [StructLayout(LayoutKind.Explicit)]
        private readonly struct Union
        {
            [FieldOffset(0)] internal readonly T1 Item1;
            [FieldOffset(0)] internal readonly T2 Item2;

            internal Union(T1 value) : this() => this.Item1 = value;
            internal Union(T2 value) : this() => this.Item2 = value;
        }

        public enum TypeIndex : byte { None, Type1, Type2 }

        private readonly Union Value;

        public readonly TypeIndex Index;

        byte V2.Details.IValueVariant.TypeIndex { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => (byte)this.Index; }

        private CharacterId(in Union value, TypeIndex index)
            => (this.Value, this.Index) = (value, index);

        public CharacterId(T1 value) : this(new Union(value), TypeIndex.Type1) { }
        public CharacterId(T2 value) : this(new Union(value), TypeIndex.Type2) { }

        public T1 Item1 { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => this.Index == TypeIndex.Type1 ? this.Value.Item1 : ThrowInvalidCastException<T1>(); }
        public T2 Item2 { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => this.Index == TypeIndex.Type2 ? this.Value.Item2 : ThrowInvalidCastException<T2>(); }

#if NETSTANDARD2_1_OR_GREATER
        [DoesNotReturn]
#endif
        private static TV ThrowInvalidCastException<TV>() => throw new InvalidCastException();

        public static implicit operator T(T1 value) => new T(value);
        public static implicit operator T(T2 value) => new T(value);

        public static explicit operator T1(in T value) => value.Item1;
        public static explicit operator T2(in T value) => value.Item2;

        public bool Equals(T other)
            => V2.Details.ValueVariant<T1, T2>.Equals(this, other);

#if NETCOREAPP2_1_OR_GREATER
        public override bool Equals([NotNullWhen(true)] object? obj)
#else
        public override bool Equals(object obj)
#endif
            => obj is T other && this.Equals(other);

        public static bool operator ==(in T lhs, in T rhs)
            => lhs.Equals(rhs);

        public static bool operator !=(in T lhs, in T rhs)
            => !lhs.Equals(rhs);

        public override int GetHashCode()
            => V2.Details.ValueVariant<T1, T2>.GetHashCode(this);

        public override string ToString()
            => V2.Details.ValueVariant<T1, T2>.ToString(this);

        public interface IActionVisitor : V2.IValueVariantActionVisitor<T1>, V2.IValueVariantActionVisitor<T2> { }

        public interface IActionVisitor<in TA1> : V2.IValueVariantActionVisitor<T1, TA1>, V2.IValueVariantActionVisitor<T2, TA1> { }

        public interface IFuncVisitor<out TR> : V2.IValueVariantFuncVisitor<T1, TR>, V2.IValueVariantFuncVisitor<T2, TR> { }

        public interface IFuncVisitor<in TA1, out TR> : V2.IValueVariantFuncVisitor<T1, TA1, TR>, V2.IValueVariantFuncVisitor<T2, TA1, TR> { }

        public TR Accept<TR>(IFuncVisitor<TR> visitor)
        {
            this.Accept(visitor, out TR result);
            return result;
        }

        public TR Accept<TA1, TR>(IFuncVisitor<TA1, TR> visitor, TA1 arg1)
        {
            this.Accept(visitor, arg1, out TR result);
            return result;
        }

        public void Accept<TV>(in TV visitor)
            where TV : V2.IValueVariantActionVisitor<T1>, V2.IValueVariantActionVisitor<T2>
            => V2.Details.ValueVariant<T1, T2>.AcceptActionVisitor(this, visitor);

        public void Accept<TV, TA1>(in TV visitor, TA1 arg1)
            where TV : V2.IValueVariantActionVisitor<T1, TA1>, V2.IValueVariantActionVisitor<T2, TA1>
            => V2.Details.ValueVariant<T1, T2>.AcceptActionVisitor(this, visitor, arg1);

        public void Accept<TV, TR>(in TV visitor, out TR result)
            where TV : V2.IValueVariantFuncVisitor<T1, TR>, V2.IValueVariantFuncVisitor<T2, TR>
            => result = V2.Details.ValueVariant<T1, T2>.AcceptFuncVisitor<T, TV, TR>(this, visitor);

        public void Accept<TV, TA1, TR>(in TV visitor, TA1 arg1, out TR result)
            where TV : V2.IValueVariantFuncVisitor<T1, TA1, TR>, V2.IValueVariantFuncVisitor<T2, TA1, TR>
            => result = V2.Details.ValueVariant<T1, T2>.AcceptFuncVisitor<T, TV, TA1, TR>(this, visitor, arg1);

        public void Accept(V2.IValueVariantGenericActionVisitor visitor)
            => V2.Details.ValueVariant<T1, T2>.AcceptGenericActionVisitor(this, visitor);

        public void Accept<TA1>(V2.IValueVariantGenericActionVisitor<TA1> visitor, TA1 arg1)
            => V2.Details.ValueVariant<T1, T2>.AcceptGenericActionVisitor(this, visitor, arg1);

        public TR Accept<TR>(V2.IValueVariantGenericFuncVisitor<TR> visitor)
            => V2.Details.ValueVariant<T1, T2>.AcceptGenericFuncVisitor<T, V2.IValueVariantGenericFuncVisitor<TR>, TR>(this, visitor);

        public TR Accept<TA1, TR>(V2.IValueVariantGenericFuncVisitor<TA1, TR> visitor, TA1 arg1)
            => V2.Details.ValueVariant<T1, T2>.AcceptGenericFuncVisitor<T, V2.IValueVariantGenericFuncVisitor<TA1, TR>, TA1, TR>(this, visitor, arg1);

        public readonly struct DefaultConverter : IFuncVisitor<T>
        {
            public T Visit(in T1 value) => value;
            public T Visit(in T2 value) => value;
        }

        private sealed class MessagePackFormatter : IMessagePackFormatter<T>
        {
            public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
            {
                options.Resolver.GetFormatterWithVerify<byte>().Serialize(ref writer, (byte)value.Index, options);
                switch (value.Index) {
                    case TypeIndex.None: return;
                    case TypeIndex.Type1: options.Resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options); return;
                    case TypeIndex.Type2: options.Resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options); return;
                    default: throw new InvalidOperationException();
                }
            }

            public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
            {
                var index = (TypeIndex)options.Resolver.GetFormatterWithVerify<byte>().Deserialize(ref reader, options);
                switch (index) {
                    case TypeIndex.None: return default(T);
                    case TypeIndex.Type1: return new T(options.Resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options));
                    case TypeIndex.Type2: return new T(options.Resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options));
                    default: throw new InvalidOperationException();
                }
            }
        }
    }
}
